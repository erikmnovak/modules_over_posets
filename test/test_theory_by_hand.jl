using Test

@testset "By-hand theory checks (Miller Prop 3.10 and chain intervals)" begin

    @testset "Prop 3.10: Hom for indicator modules uses pi0 on Hasse graph" begin
        # Disjoint union of two chains: 1<2 and 3<4 (no relations between components).
        P = disjoint_two_chains_poset()

        allU = FF.upset_closure(P, trues(P.n))
        allD = FF.downset_closure(P, trues(P.n))

        # U = upset generated by {2,4} is just {2,4}.
        # D = downset generated by {2,4} is the whole poset.
        U = FF.upset_from_generators(P, [2, 4])
        D = FF.downset_from_generators(P, [2, 4])

        # k[U] as a fringe image: k[U] -> k[Q] (death = all).
        kU = one_by_one_fringe(P, U, allD)

        # k[D] as a fringe image: k[Q] -> k[D] (birth = all).
        kD = one_by_one_fringe(P, allU, D)

        # Prop 3.10(1): dim Hom_Q(k[U], k[D]) = number of connected components of U cap D.
        # Here U cap D = U = {2,4}, which has 2 components.
        @test HE.pi0_count(P, U, D) == 2
        @test FF.hom_dimension(kU, kD) == 2
        @test FF.hom_dimension(kU, kD) == HE.pi0_count(P, U, D)

        # Prop 3.10(2): For upsets U',U, dim Hom(k[U'], k[U]) = number of components of U'
        # that lie inside U.
        Uprime = FF.upset_from_generators(P, [2, 4])  # {2,4} (2 components)
        Usmall = FF.upset_from_generators(P, [2])     # {2} (1 component)
        kUprime = one_by_one_fringe(P, Uprime, allD)
        kUsmall = one_by_one_fringe(P, Usmall, allD)

        @test FF.hom_dimension(kUprime, kUsmall) == 1
        @test FF.hom_dimension(kUsmall, kUprime) == 1

        # End(k[Uprime]) has one scalar per connected component of Uprime.
        @test FF.hom_dimension(kUprime, kUprime) == 2

        # Prop 3.10(3): For downsets D,D', dim Hom(k[D], k[D']) = number of components of D'
        # that lie inside D (note the direction).
        Dall = allD
        Dsmall = FF.downset_from_generators(P, [2])   # {1,2}
        kDall = one_by_one_fringe(P, allU, Dall)
        kDsmall = one_by_one_fringe(P, allU, Dsmall)

        @test FF.hom_dimension(kDall, kDsmall) == 1
        @test FF.hom_dimension(kDsmall, kDall) == 1
        @test FF.hom_dimension(kDall, kDall) == 2
    end

    @testset "Chain intervals: Hom and Ext^1 formula for type A_n" begin
        # On a finite chain, an interval module I[a,b] is indecomposable.
        # For the equioriented A_n quiver (a chain poset), the category is hereditary,
        # so Ext^t = 0 for t >= 2. Ext^1 is 1 exactly for the "one-step overlap" pattern:
        # Ext^1(I[a,b], I[c,d]) = 1 iff a < c <= b+1 <= d (and b < n so b+1 exists).
        #
        # We realize I[a,b] as the image of k[U_a] -> k[D_b] with phi = 1, where:
        #   U_a = principal upset at a  (degrees >= a)
        #   D_b = principal downset at b (degrees <= b)
        n = 4
        P = chain_poset(n)

        function interval_module(a::Int, b::Int)
            @assert 1 <= a <= b <= n
            U = FF.principal_upset(P, a)
            D = FF.principal_downset(P, b)
            return one_by_one_fringe(P, U, D)
        end

        intervals = [(a, b) for a in 1:n for b in a:n]
        mods = Dict{Tuple{Int,Int}, FF.FringeModule{QQ}}()
        for (a, b) in intervals
            mods[(a, b)] = interval_module(a, b)
        end

        for (a, b) in intervals, (c, d) in intervals
            M = mods[(a, b)]
            N = mods[(c, d)]

            ext = IR.ext_dimensions_via_indicator_resolutions(M, N; maxlen=5)

            # Hom(I[a,b], I[c,d]) is 1 iff c <= a <= d <= b, else 0.
            expected_hom = (c <= a && a <= d && d <= b) ? 1 : 0

            # Ext^1(I[a,b], I[c,d]) is 1 iff a < c <= b+1 <= d, else 0.
            expected_ext1 = (b < n && a < c && c <= b + 1 && b + 1 <= d) ? 1 : 0

            @test get(ext, 0, 0) == expected_hom
            @test get(ext, 1, 0) == expected_ext1
            @test get(ext, 2, 0) == 0
        end

        # Sanity-check the total complex sign convention: d_{t+1} * d_t == 0.
        # Pick a pair where Ext^1 is expected nonzero to ensure differentials are not trivial.
        M = interval_module(1, 2)   # I[1,2]
        N = interval_module(2, 3)   # I[2,3]

        F, dF = IR.upset_resolution(M; maxlen=5)
        E, dE = IR.downset_resolution(N; maxlen=5)

        dimsCt, dts = HE.build_hom_tot_complex(F, dF, E, dE)
        for t in 1:(length(dts) - 1)
            @test nnz(dts[t+1] * dts[t]) == 0
        end
    end

    @testset "Zero module edge case" begin
        # A fringe module with empty intersection but zero phi should be the zero module.
        P = chain_poset(3)
        U = FF.principal_upset(P, 3)      # {3}
        D = FF.principal_downset(P, 1)    # {1}
        phi0 = spzeros(QQ, 1, 1)          # must be zero since U cap D is empty
        M0 = FF.FringeModule{QQ}(P, [U], [D], phi0)

        for q in 1:P.n
            @test FF.fiber_dimension(M0, q) == 0
        end

        # Hom from/to zero should be 0.
        U2 = FF.principal_upset(P, 2)
        D2 = FF.principal_downset(P, 2)
        M = one_by_one_fringe(P, U2, D2)

        @test FF.hom_dimension(M0, M) == 0
        @test FF.hom_dimension(M, M0) == 0

        ext = IR.ext_dimensions_via_indicator_resolutions(M0, M; maxlen=5)
        @test get(ext, 0, 0) == 0
        @test get(ext, 1, 0) == 0
    end
end
